# Front-End Performance Checklist 2020 [PDF, Apple Pages, MS Word]

>`简介` 让2020年变得更...快些吧！ 这是一份年度前端性能优化清单，包含了当下创建web快速体验所需的一切。这份清单自2016年开始已经持续更新了5年。这份清单得到了LogRocket的大力支持，LogRocket是一个前端性能监视解决方案，可帮助重现错误并更快地解决问题。

`网络性能是一头狡猾的野兽，不是吗？` 我们如何才能真正知道我们在性能方面所处的水平，以及我们的性能瓶颈到底是什么呢？ 它是昂贵的JavaScript、缓慢的Web字体传输、繁重的图像、还是缓慢的渲染？ 是否值得去研究 摇树优化、作用域提升、代码拆分，以及所有奇特的加载模式，包括交叉点观察器做懒加载、服务器推送、客户端提示、HTTP/2、service workers和 边缘计算？ 而且，最重要的是，**我们该从哪里开始做性能化**，以及我们如何建立长期的关注性能氛围？

在过去，性能往往在事后才会被考虑。通常会推迟到项目快结束时候，最终归结为压缩，串联，静态资源化，或许还有一些对服务器的`config`文件的微调。现在看来，性能优化这项工作已经发生了很大的变化。

性能不仅仅是一个技术上的问题：它会影响从 可访问性、可用性到搜索引擎优化的方方面面，当我们把性能优化引入工作流程中时，在设计上进行决策时考虑对性能影响。**性能必须不断地进行测量，监视和完善**，但是网络的日益复杂性带来了新的挑战，那就是性能指标的跟踪，因为性能指标会因设备，浏览器，协议，网络类型和网络延迟不同而有很大差异（CDN，ISP，缓存，代理，防火墙，负载均衡和服务器都对性能有着影响）。

因此，如果我们要建立了一个包含性能优化所有要点的清单（从研发开始到网站的最终上线），该清单会是什么样的呢？ 您会在下面找到一份（希望它没有偏见和客观的）** 2020年前端性能优化清单** — 您可能需要考虑性能的场景和优化手段的简介，以达到快速的响应时间，流畅的用户互动，以及网站不会浪费用户的带宽。

## 内容目录

+ Getting Ready: Planning And Metrics
+ Setting Realistic Goals
+ Defining The Environment
+ Assets Optimizations
+ Build Optimizations
+ Delivery Optimizations
+ HTTP/2
+ Testing And Monitoring
+ Quick Wins
+ Download The Checklist (PDF, Apple Pages, MS Word)
Off We Go!

## 准备工作：计划和指标

不时的小优化对于保持良好性能很有效果，但更重要的是：在头脑中明确性能目标-需要是可衡量的目标，因为这将影响整个开发过程中我们所做的任何决策。下面有几种不同的性能指标模型，下面关于这些模型的讨论会比较主观--您只要确保在工作开始时设置自己的优先级即可。

### 01 建立性能优化的文化

在许多团队中，前端开发工程师都明确地知道那些常见的性能问题，以及使用何种加载方式能够解决这些问题。但是因为缺乏对性能优化的文化，每一项关于性能的决策都演变成了部门之间的战场，把组织分裂成1一个个孤岛。您需要业务方的支持，如何获取支持呢？首先需要进行一个案例研究，或使用[Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Performance)来[证明](https://medium.com/@armelpingault/how-to-convince-your-client-to-focus-on-web-performance-a-case-study-35f12385689)性能如何提升他们关心的工作指标和关键绩效指标（KPI）。

如果开发/设计团队与业务/营销团队之间无法对性能优化的目标保持一致，那性能优化将无法长期维持。因此性能优化的工作需要关注客户服务和销售团队的常见投诉，研究高退货率和低转化率的原因。探索性能优化如何帮助缓解这些常见问题，并根据与你交谈的利益方[调整你的论点](https://youtu.be/SE0HhF4TO0Q?t=1052)。

运行性能实验并测量结果 - 无论是在移动设备上还是在桌面上(例如，使用Google Analytics) 将帮助你用真实的数据为公司进行定制性的分析。 此外，使用发布在WPO Stats上的研究案例和实验数据，也可以帮助我们明确性能对业务提升的重要性，以及它对用户体验和业务指标的影响。 然而，仅仅说明性能很重要是不够的 - 您还需要建立一些可衡量和可跟踪的目标，并随着持续跟踪相关指标。

怎么去那里？ 艾莉森·麦克奈特(Allison McKnight)在她关于长期建筑绩效的演讲中，分享了一个全面的案例研究-如何帮助Etsy建立了一种重视性能的文化(幻灯片)。 最近，塔米·埃弗茨(Tammy Everts)也谈到了在小型和大型组织中，如何培养高效性能团队的习惯。

![Performance budget builder by Brad Frost and Jonathan Fielding’s Performance Budget Calculator can help you set up your performance budget and visualize it. (Large preview)](./images/brad-perf-budget-builder.png)

> 由布拉德·弗罗斯特（Brad Frost）的性能预算生成器和乔纳森·菲尔丁（Jonathan Fielding）的性能预算极端起可以帮助您设置性能预期并对其进行可视化。

### 02 目标:比你最快的竞争对手至少快20%

根据[用户心理学研究](https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule)，如果想让用户感觉你的web网站比其它竞品快，那你必须比它们快20%以上。研究您的主要竞争对手，收集它们在移动设备和台式机上的性能指标，并设置阈值以帮助您超越竞争对手。 但是，要获取准确的性能指标并制定目标，请务必先通过研究分析来全面了解用户体验。 然后，你可以根据90％用户反馈和经验来模拟测试。

你可以使用[Chrome UX Report](https://web.dev/fast/chrome-ux-report) (也叫CrUX, 一个现成的实际用户体验监控报告, 参考Ilya Grigorik的[视频介绍](https://vimeo.com/254834890) 和 Rick Viscomi的[详情使用指南](https://dev.to/rick_viscomi/a-step-by-step-guide-to-monitoring-the-competition-with-the-chrome-ux-report-4k1o))或者[Treo网站](https://treo.sh/sites)，一个由Chrome UX报告提供支持的实际用户分析监视工具。作为替代品，你也可以使用[Speed Scorecard](https://www.thinkwithgoogle.com/feature/mobile/) (也提供对网站收入影响的评估)[Real User Experience Test Comparison](https://ruxt.dexecure.com/compare) 或者[SiteSpeed CI](https://www.sitespeed.io/) (基于综合测试)。

![Treo Sites provides competitive analysis based on real-world data. (Large preview)](./images/10-treo-front-end-performance-checklist-2020.jpeg)

>Treo Sites 根据实际数据提供网站竞争性分析（点击放大预览）

**注**: 如果你使用[Page Speed](https://developers.google.com/speed/pagespeed/insights/) Insights或者[Page Speed Insights API](https://dev.to/addyosmani/monitoring-performance-with-the-pagespeed-insights-api-33k7) (不，它没有被弃用)。除了汇总数据，您也可以获取特定页面的CrUX性能数据。这些数据对于为 "落地页" 或 "产品列表" 之类的页面单独设置性能目标可能更有用。 补充说明，如果您使用CI来测试预期，则需要确保您的测试环境与CrUX匹配，然后再使用CrUX设置目标（感谢Patrick Meenan反馈！）。

如果您想知道显示速度优先级排序背后的原因，或者您想要可视化来展示页面转换率下降、跳出率增加后者性能降低，或者您可能需要在组织中倡导基于真实用户体验的解决方案，Sergey Chernyshev [已经开发](https://calendar.perfplanet.com/2019/visualizing-speed-without-real-data/) a [UX 速度计算器](https://ux-speed-calculator.netlify.com/), 一个开源工具，可以帮助你拟合数据并将其可视化，验证你的观点。

![Just when you need to make a case for performance to drive your point across: UX Speed Calculator visualizes an impact of performanc on bounce rates, conversion and total revenue — based on real data. (Large preview)](./images/16-ux-speed-calculator-front-end-performance-checklist-2020.png)

>在需要提高性能来说明您的观点时：UX 速度计算器基于真实数据，可以把性能对页面转化率、跳出率和总收入的影响用可视化的图标展示。（点击放大预览）

收集数据，建立表格，以提升20%的性能思路设定你的目标(性能预算)。现在你有了可以衡量的东西来测试了。如果你把预算记在心里，试着把最小的有效载荷降下来，以获得一个快速的交互时间，这样就是一个正确的性能优化方式。

需要一些资源来开始？

+ 阿迪·奥斯马尼(Addy Osmani)写了一篇非常详细的文章，内容包括[如何开始做性能预算](https://medium.com/@addyosmani/start-performance-budgeting-dabde04cf6a3)，如何量化新功能的影响，以及当你超出预算时从哪里开始优化。

+ 劳拉·霍根(Lara Hogan)[关于如何在性能预算下进行设计的指南](http://designingforperformance.com/weighing-aesthetics-and-performance/#approach-new-designs-with-a-performance-budget)可以为设计师提供有用的指导。

+ 哈利·罗伯特(Harry Roberts)发布了一份[指南](https://csswizardry.com/2018/05/identifying-auditing-discussing-third-parties/)，介绍如何使用[请求地图](http://requestmap.webperf.tools/)设置Google工作表，以显示第三方脚本对性能的影响。

乔纳森·菲尔丁(Jonathan Fiding)的[性能预算计算器](http://www.performancebudget.io/)、凯蒂·亨佩纽斯(Katie Hempenius)的[性能预算计算器](https://perf-budget-calculator.firebaseapp.com/)和[浏览器卡路](https://browserdiet.com/calories/)里可以帮助创建预算(感觉卡罗琳娜·斯库尔([Karolina Szczur](https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3))的反馈)。

此外，可以设置带有报告构建大小的图形的仪表板，使性能预算和当前性能变得可视化。 有许多工具可以实现：[SiteSpeed.io仪表板](https://www.sitespeed.io/)(开源)、[SpeedCurve](http://speedcurve.com/)和[Calibre](https://calibreapp.com/)只是其中的一小部分，您可以在[Perform.rocks](http://perf.rocks/tools/)上找到更多工具。

一旦有了性能预算，就可以将它们与[Webpack性能提示和Bundlesize](https://web.dev/fast/incorporate-performance-budgets-into-your-build-tools)、[Lighthouse CI](Lighthouse CI)、[PWMetrics](https://github.com/paulirish/pwmetrics)或[Sitespeed CI](https://www.sitespeed.io/)结合到构建过程中，这样就可以在合并请求(pull requests)时考虑性能预算，并在PR评论中提供评分历史。

要向整个团队公开性能预算，可以[通过Lightwallet在Lighthouse中集成性能预算](https://web.dev/use-lighthouse-for-performance-budgets/)，或者[使用LHCI动作来快速集成到 Github Actions](https://github.com/treosh/lighthouse-ci-action)。如果需要自定义，可以使用[WebPagetest -chart-API](webpagetest-charts-api)，这是一种端点API，用于根据WebPagetest结果构建图表。

不过，性能意识不应该仅仅来自性能预算。就像[Pinterest](Pinterest)一样，您可以创建一个[自定义eslint规则](https://medium.com/pinterest-engineering/a-one-year-pwa-retrospective-f4a2f4129e05#d6bc)，比如不允许导入依赖关系较重且会使构建产物膨胀的文件或目录。设置一个在整个团队中共享的"放心使用"包列表。

此外，还要考虑对您的业务最有利的关键客户任务。研究、讨论和定义**关键操作的可接受时间阈值**，并建立整个组织认可的“UX Ready”用户计时标记。在许多情况下，用户浏览和行为路径将涉及许多不同部门的工作，因此，根据可接受的时间进行调整将有助于支持或阻止以后的性能讨论。 确保增加资源和功能的额外成本是可见的和理解的。

将性能优化与其他技术活动结合起来，从构建产品的新特性到重构，再到面向新的全球受众。因此，每次关于开发的讨论发生时，性能也需要纳入其中。一般来说，当项目代码库是全新的或者重构时，更容易达到性能目标。在你的组织中建立了一个强大的性能文化，目标是比你以前的自己快20%，随着时间的流逝保持优先级。(谢谢,小伙子Podjarny !)

另外，就像 Patrick Meenan 所建议的，在UX设计过程中就权衡加载顺序是很有用的方式。如果您及早确定页面中哪些组件比较关键，并定义它们应该出现的顺序，那就会确定哪些组件可以延迟。理想情况下，该顺序还将反映CSS和JavaScript导入的顺序，因此在构建过程中处理它们的顺序会变得更加容易。此外，在加载页面时(例如，当网页字体尚未加载时)，请考虑在“中间”状态下的视觉体验应该是什么。

规划、计划、规划。在早期进行快速的“容易够得着的水果”似的性能优化可能很诱人，也是一个能快速取得成功的好策略，但是如果没有规划，没有切合实际的、为公司量身定制的性能目标，在长期的开发过程中就很难一直把性能放在首位。

[第一次绘制、第一次有内容绘制、第一次有意义的绘制、视觉完成和可交互时间之间的区别](https://docs.google.com/presentation/d/1D4foHkE0VQdhcA5_hiesl8JhEGeTDRrQR4gipfJ8z7Y/present?slide=id.g1d1bfb0329_0_542)@denar90

![11-metrics-front-end-performance-checklist-2020](./images/11-metrics-front-end-performance-checklist-2020.png)

>2020年初，新的性能指标将在Lighthouse v6中发布。不再推荐使用“第一次有意义的涂料（FMP）”，并且再下个Lighthouse版本中引入最大内容绘制时间（LCP）和总阻塞时间（TBT）这两个指标。

### 03 选择正确的指标

[并不是所有的指标都同样重要](https://speedcurve.com/blog/rendering-metrics/)。研究哪些指标对您的应用程序最重要：通常，它将由开始呈现界面中最重要的像素的速度以及为这些呈现的像素提供输入响应的速度来定义。这些知识将为您提供最佳的优化目标，以进行不断的正确方向的努力。再强调一点，定义体验的指标不是加载事件或服务器响应时间，而是用户感觉界面有多快。

什么意思？ 与其关注整个页面加载时间(例如，通过onLoad和DOMContentLoaded计时)，不如按照用户的看法确定页面加载的优先级。这意味着你会着关注一组略有不同的指标。事实上，选择正确的指标是一个没有明确结束点的过程。

根据Tim Kadlec的研究和Marcos Iglesias在他的[演讲](https://docs.google.com/presentation/d/e/2PACX-1vTk8geAszRTDisSIplT02CacJybNtrr6kIYUCjW3-Y_7U9kYSjn_6TbabEQDnk9Ao8DX9IttL-RD_p7/pub?start=false&loop=false&delayms=10000&slide=id.g3ccc19d32d_0_98)中的笔记，传统的度量指标可以分成几组。通常，我们需要所有这些度量指标才能全面了解性能，但是根据您的特定情况，其中一些指标可能比其他更重要。

+ 基于数量的指标: 测量请求的数量、权重和性能分数。这对于随时间做监控和警报很有帮助，但对于理解用户体验来说不够完美。

+ 里程碑式的指标：在加载过程的生命周期中使用状态来度量，例如，到第一个字节的时间、可交互的时间。这些指标很适合描述用户体验和监控，但不太适合了解各个里程碑之间发生的事情。

+ 渲染的指标: 提供对内容渲染速度的估计(例如，开始渲染时间，速度指数)。对于度量和调整渲染性能很好，但是在度量重要内容的出现时间和可交互时间方面，这些指标就不太好用了。

+ 自定义的指标: 对用户的特定自定义事件的度量，例如Twitter中[首次Tweet渲染时间](https://blog.alexmaccaw.com/time-to-first-tweet)和Pinterest的[PinnerWaitTime](PinnerWaitTime)。对于精确地描述用户体验来说很好，但是对于度量标准和与竞争对手的比较来说就不那么好了。

为了使性能指标这块拼图更完整，我们会在所有这些组中寻找有用的指标。通常，最具体和最相关的是：

+ [Time to Interactive](https://calibreapp.com/blog/time-to-interactive/) (TTI)
  
    布局已经稳定、关键的Web字体可见、并且主线程已经空闲下来可以处理用户输入的时间点-基本上就是用户可以与UI交互的时间标记。这是了解用户必须经历多少等待才能毫无延迟地使用网站的关键指标。

+ [First Input Delay](https://developers.google.com/web/updates/2018/05/first-input-delay) (FID), *or Input responsiveness*

    从用户首次与网站进行交互到浏览器实际上能够响应该交互的时间。它很好地补充了TTI指标缺少的那部分：当用户实际与站点进行交互时会发生什么。 一般仅用作RUM度量标准。有一个[标准的JavaScript库](https://github.com/GoogleChromeLabs/first-input-delay)，用于在浏览器中测量FID。

+ [Largest Contentful Paint](https://web.dev/lcp/) (LCP)

    这是在页面加载时间线中，标记已加载页面重要内容的时间点。假设页面中最重要的元素是在用户的视区中可见的最大元素。如果元素同时在可视区域的上方和下方渲染，只有可见部分被认为是相关的。目前在Lighthouse中，它是一个隐藏的指标，如果证明是有价值的，后续会推广。

+ [Total Blocking Time](https://web.dev/tbt/) (TBT)

    这是一种新的度量标准，有助于量化页面在变为可靠交互之前处于非交互状态的严重程度（也就是说，主线程至少在5s内没有运行超过50ms的任务（长任务））。度量的是从第一次绘画（FP）到交互时间（TTI）之间的时间长短（在这段时间内，主线程被阻塞足够长的时间而无法响应用户输入）。所以说，低的TBT是良好性能的体现。（感谢 [Boris](https://twitter.com/borisschapira) Artem）

+ [Cumulative Layout Shift](https://web.dev/cls)（CLS）
    该指标突出显示了用户访问网站时多久遇到一次意外的版式变化（重排）。它研究了不稳定因素及其对整体体验的影响。分数越低越好。

+ [Speed Index](https://dev.to/borisschapira/web-performance-fundamentals-what-is-the-speed-index-2m5i)
    度量页面内容可视化填充的速度，分数越低越好。速度指数分数是根据视觉填充的速度计算的，但它只是一个计算值。它对视口大小也很敏感，所以您需要定义一系列与您的目标用户是被相匹配的测试配置。请注意，随着LCP作为一种新度量标准的出现，它变得不那么重要了(谢谢，Boris, Artem!)。

+ CPU time spent

    这是显示主线程被阻塞的频率和时间的度量指标，受到浏览器绘制、渲染、加载和执行JS等动作的影响。高CPU时间是不稳定体验的明显指标，也就是说，这时候用户会体验到他们的操作和响应之间存在明显的滞后。使用WebPagetest，您可以[在“Chrome”选项卡上选择“Capture Dev Tools Timeline”](https://deanhume.com/ten-things-you-didnt-know-about-webpagetest-org/)，以显示在使用WebPagetest的任何设备上运行时，主线程的被阻塞的具体细节。

+ [Component-Level CPU Costs](https://calendar.perfplanet.com/2019/javascript-component-level-cpu-costs/)

    类似上面的 CPU time spent，这个由Stoyan Stefanov提出的指标主要用于度量JavaScript对CPU的影响。这个指标的想法是使用每个组件的CPU指令计数来独立地了解每个组件中Javascript其对整体体验的影响。可以[使用Puppeteer和Chrome来测量]((https://calendar.perfplanet.com/2019/javascript-component-level-cpu-costs/))。

+ [FrustrationIndex](https://www.frustrationindex.com/)（沮丧指数）

    上面介绍的许多指标解释了特定事件发生的时间，而Tim Vereecket提出的FrustrationIndex指标则着眼于各个里程碑之间的间隔，而不是独立地衡量它们。它衡量最终用户感知到的关键里程碑，例如 标题可见、第一个内容可见、视觉上准备就绪、页面准备就绪，并计算一个分数，指示加载页面时的沮丧程度。间隔时间越大，用户感到沮丧的可能性就越大。对于用户体验而言，这可能是一个很好的KPI。Tim发表了一篇[FrustrationIndex介绍及其工作原理的详细帖子](https://calendar.perfplanet.com/2019/frustrationindex-mind-the-gap/)。

+ [Ad Weight Impact](https://calendar.perfplanet.com/2017/measuring-adweight/)

    如果您的站点依赖于广告产生的收入，那么跟踪与广告相关的代码大小是很有用的。Paddy Ganti写了1个[脚本](https://calendar.perfplanet.com/2017/measuring-adweight/)，可以构建了两个URL(一个正常，一个阻止广告)，通过WebPagetest提示可以生成比较视频，并报告广告的增量。

+ Deviation metrics（偏差指标）

    正如Wikipedia工程师指出的那样，结果中存在多少差异的数据可以侧面反映您测量仪器的可靠性，以及应该对偏差和异常值给予多大的关注。较大的差异表明测试仪器的设置中需要进行调整。它还有助于了解某些页面是否更难以可靠地衡量，例如 “由于第三方脚本会导致重大变化”。跟踪浏览器版本也是一个好主意，这样可以方便地了解新版本的浏览器对性能的提高。

+ [Custom metrics](https://speedcurve.com/blog/user-timing-and-custom-metrics/)

    自定义指标的定义来源于您的业务需求和客户体验。它要求您明确页面中重要的像素、关键脚本、必要的CSS和相关资源，并衡量它们对用户感知速度的影响。对于这一点，您可以监控[Hero Rendering Times](https://speedcurve.com/blog/web-performance-monitoring-hero-times/)，或者使用[Performance API](https://css-tricks.com/breaking-performance-api/)，为对您的业务非常重要的事件标记特定的时间戳。 此外，您还可以通过在测试结束时执行任意JavaScript来[使用WebPagetest收集自定义指标](collect custom metrics with WebPagetest)。

请注意，“[首次有意义渲染时间（FMP）](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint)”并未出现在上面。FMP用于深入了解服务器首次输出任何有意义数据的速度。较大的FMP通常反映JavaScript阻塞了主线程，也可能是后端/服务器出现了其他问题。但是，该度量标准最近已被[弃用](https://calendar.perfplanet.com/2019/developing-the-largest-contentful-paint-metric/)，因为在大约20％的情况下它似乎并不准确。Lighthouse也将在下一版本[不再支持FMP](https://www.youtube.com/watch?v=iaWLXf1FgI0&feature=youtu.be&t=505) 仔细检查[最新的以用户为中心的性能指标和建议](https://web.dev/metrics/)，以确保您对页面性能时监测时可靠的。

史蒂夫·苏德斯(Steve Souders)对每个指标都进行了[详细的解释](https://speedcurve.com/blog/rendering-metrics/)。 需要注意的是，可交互时间(TTI)是通过在实验室环境中运行自动审核来测试的，而首次输入延迟(FID)这种需要实际的用户体验的指标，实际用户在体验时会明显感觉比测试中的慢。总体而言，始终测量和跟踪这两个参数应该是个不错的主意。

根据您的应用环境，首选指标可能会有所不同，举两个例子：对于Netflix TV UI，按键输入响应性，内存使用率和TTI更为关键，而对于Wikipedia而言，最先/最后的视觉变化时间点和CPU时间消耗指标则更为重要。

**注**:FID和TTI都没有考虑用户滚动行为；滚动可以独立进行，因为它是非主线程的，所以对于许多内容消费站点来说，这些滚动相关指标可能不那么重要(谢谢Patrick提醒!)

![network-requests-first-input-delay](./images/network-requests-first-input-delay.png)

>以用户为中心的性能指标可以更好地反映实际的用户体验。首次输入延迟(FID)是一个新的度量标准，它试图实现这一点。

### 04 收集典型用户的设备上的数据

为了收集准确的数据，我们需要彻底全面地选择要测试的设备。在大多数公司中，这意味着需要调查分析并根据最常见的设备类型创建用户个人资料。但是一般情况下，仅凭分析并不能提供完整的信息。仅仅因为他们的体验太慢并且他们的设备不太可能显示为分析中最受欢迎的设备，所以很大一部分目标受众可能会放弃该网站（而不是返回）。因此，另外对目标群体中的通用设备进行研究可能是一个好主意。

根据国际数据公司(IDC)的数据显示，2018年至2019年期间，[全球87%的移动电话都是Android设备](https://www.idc.com/promo/smartphone-market-share/os)。[消费者平均每两年升级一次手机](https://www.cnbc.com/2019/05/17/smartphone-users-are-waiting-longer-before-upgrading-heres-why.html)，而在美国，[手机更换周期为33个月](https://www.mobileworldlive.com/devices/news-devices/us-phone-upgrade-cycle-stretches-to-33-months/)。全球最畅销手机的平均售价将低于200美元。

那么，需要有个代表性的设备：已经使用至少24个月的Android设备、价格在200美元或更低、运行在低速3G、400ms RTT和400kbps传输模式下，这只是稍微悲观的预期的设置。当然，对于您的公司来说，这可能会非常不同，但这已经足够接近大多数客户了。事实上，针对您的目标市场调查一下当前的[亚马逊畅销机型](https://www.amazon.co.uk/gp/bestsellers/electronics/356496011/ref=sr_bs_1)可能是个不错的主意。 (感谢Tim Kadlec，Henri Helvetica和Alex Russel的指点!)

那么选择什么样的测试设备呢？按上面描述的样子，我们是在开放的设备实验室里，选择Moto G4/G5 Plus，三星中端设备(Galaxy A50，S8)，不错的中档设备，如Nexus 5X，小米A3或小米Redmi Note 7，以及速度较慢的Alcatel 1X或Cubot X19，这是一个不错的组合。对于较慢的热油门设备的测试，你也可以买一台Nexus4，价格只有100美元左右。

此外，检查每个设备使用的芯片组，机型组合**不要过度集中在一个芯片组中**: 建议包含几代的骁龙CPU（Snapdragon）和苹果CPU（Apple）以及低端的Rockchip、联发科（Mediatek）(谢谢，Patrick提醒!)

如果您手头没有设备，可以先在在台式机上模拟移动体验：**节流的3G网络**(例如300ms RTT、1.6 Mbps下行、0.8 Mbps上行)和CPU限速(减速5倍)上进行测试。 最终切换到常规3G、低速4G(例如170ms RTT、9 Mbps下行、9 Mbps上行)和Wi-Fi。为了让性能影响更明显，你甚至可以[参考facebook的做法在每个周二引入2G网络](https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world)，或者在办公室设置一个[节流的3G/4G网络](https://twitter.com/thommaskelly/status/938127039403610112)，更方便地进行测试。

请记住，在移动设备上，我们应该预期会[比台式机慢4到5倍](https://youtu.be/JvJ0v5OohNg?t=892)。移动设备有不同的GPU、CPU、内存和不同的电池。这就是为什么我们需要真机测试组合，[并且始终在这些设备上进行测试](https://www.webpagetest.org/easy)。

![tuesday-2g-opt](./images/tuesday-2g-opt.png)

>一周中最慢的一天。Facebook推出了2G的周二服务，让慢网速更容易被体验和可视化。

幸运的是，有许多很棒的选项可以帮助您自动收集数据，并根据这些指标衡量您的网站在一段时间内的表现。请记住，良好的性能图表应该含有一组性能指标，并且每个指标都有实验室数据和真机数据：

+ **综合测试工具** 可以在通过设定好的设备和网络选项来模拟真机，并收集测试数据(例如Lighthouse，Calibre，WebPageTest)
+ **真实用户监控(RUM)工具** 可以持续评估用户交互并收集现场数据(例如SpeedCurve、New Relic--并且这些工具也提供综合测试)

前者在开发期间特别有用，因为它能帮助您在开发产品时识别、隔离和修复性能问题。后者则对于长期维护非常有用，因为它将帮助您了解在用户实际访问站点时正在发生的性能瓶颈。

通过利用内置的RUM API（如[导航时间](https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API)，[资源加载时间](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API)，[渲染时间](https://css-tricks.com/paint-timing-api/)，[长任务](https://w3c.github.io/longtasks/)等），综合测试工具和RUM可一起为您的Web应用程序提供完整的性能图。您可以使用[PWMetrics](https://github.com/paulirish/pwmetrics)，[Calibre](https://calibreapp.com/)，[SpeedCurve](https://speedcurve.com/)，[mPulse](https://www.soasta.com/performance-monitoring/)和[Boomerang](https://github.com/yahoo/boomerang)，[Sitespeed.io](https://www-origin.sitespeed.io/)，它们都是性能监控的绝佳选择 此外，[使用Server Timing返回头](https://www.smashingmagazine.com/2018/10/performance-server-timing/)，您甚至可以在页面中的某个点同时监控后端和前端的性能。

**注**：在浏览器[外部使用网络调节器](https://calendar.perfplanet.com/2016/testing-with-realistic-networking-conditions/)总是比使用浏览器内置的更为可靠，例如，DevTools由于其实现方式的原因，在HTTP/2的push过程中，交互时长存在问题（感谢Yoav，Patrick反馈！）。对于Mac OS，我们可以使用[Network Link Conditioner](https://nshipster.com/network-link-conditioner/)，Windows中可以使用[Windows Traffic Shaper](https://github.com/WPO-Foundation/win-shaper/releases)，Linux中可以使用[netem](https://wiki.linuxfoundation.org/networking/netem)和FreeBSD的[虚拟网络](http://info.iet.unipi.it/~luigi/dummynet/)。

![lighthouse-screenshot](./images/lighthouse-screenshot.png)

>Lighthouse是集成在DevTools中的一个性能审计工具

### 05 分别建立“干净”和“客户”配置文件用于测试

在监控工具中运行测试时，通常的策略是关闭杀毒软件和占用CPU的后台任务，清除后台带宽传输，使用干净的用户配置文件进行测试，并且不使用浏览器扩展，以避免出现不正确的结果([Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiple_profiles)、[Chrome](https://support.google.com/chrome/answer/2364824?hl=en&co=GENIE.Platform=Desktop))。

补充一下，最好研究一下客户经常使用的扩展，并使用专用的“客户”配置文件进行测试。实际上，某些扩展可能会对您的应用程序产生[深远的性能影响](https://twitter.com/denar90_/statuses/1065712688037277696)（[研究](https://www.debugbear.com/blog/measuring-the-performance-impact-of-chrome-extensions)），并且，如果您的用户经常使用它们，则可能需要先考虑一下。仅仅做到“干净”配置文件会导致结果过于乐观，而在用户实际体验的时候表现很糟。

### 06 与您的同事分享绩效目标

确保团队的每个成员都熟悉绩效目标，以免造成误解。每个决策-无论是设计，营销还是介于两者之间的任何决策-都会影响绩效，并且在整个团队中分配责任和所有权将在以后简化以绩效为中心的决策。据性能预算和早期定义的优先级来权衡设计决策。

## 设定现实的目标

### 07 响应时间100ms，每秒60帧

为了让交互感觉流畅，页面响应用户的输入动作最好小于100ms。如果超过这个时间，用户就会觉得这个页面很迟钝。Rails是一个以用户为中心的性能模型，它为您提供了健康页面的目标：为了达到<100毫秒的响应时间，页面必须每隔<50毫秒将控制权交还给主线程。[输入延迟估计](https://developers.google.com/web/tools/lighthouse/audits/estimated-input-latency)可以告诉我们是否达到该阈值，理想情况下，它应该低于50ms。对于像动画这样的敏感点，最好在你执行动画的时候什么都不做。

![rail-perf-model-opt](./images/rail-perf-model-opt.png)

>[RAIL](https://developers.google.com/web/fundamentals/performance/rail), 一个以用户为中心的性能模型

另外，动画的每一帧都应在16毫秒内完成，从而达到每秒60帧（1秒÷60 = 16.6毫秒）-最好在10毫秒以内。由于浏览器需要时间才能在屏幕上绘制新帧，因此您的代码应在达到16.6毫秒之前完成执行。我们开始进行有关120fps的对话（例如iPad Pro的屏幕以120Hz运行），Surma涵盖了一些[120fps的渲染性能解决方案](https://dassur.ma/things/120fps/)，但这可能有点超前了，不是我们目前追求的目标。

对性能预期持悲观态度，[对界面设计持乐观态度](be optimistic in interface design)，[合理利用空闲时间](https://philipwalton.com/articles/idle-until-urgent/)(关注[idlize](https://github.com/GoogleChromeLabs/idlize)和[idle-until-urgent](https://github.com/TehShrike/idle-until-urgent))。当然，上面说的这些目标适用于衡量运行时性能，而不是加载性能。

### 08 3G环境下 FID < 100ms, TTI < 5s, Speed Index < 3s, 关键文件大小 < 170KB (gzip压缩后)

虽上述指标可能很难实现，但一个好的最终目标是[速度指数（Speed Index）](https://web.dev/speed-index/)低于3s，[可互动时间(TTI)低于5s](https://www.youtube.com/watch?v=_srJ7eHS3IM&feature=youtu.be&t=6m21s)，对于二次访问，TTI目标是低于2s(一般需要利用Services Work的离线缓存才能实现)。最大内容绘制时间(LCP)的目标是1s以下，最大限度地减少总阻塞时间和累计布局变动。可接受的首次输入延迟(在LightHouse突出显示最大潜在首次输入延迟)要低于130-100ms。如上所述，我们正在考虑的基准是200美元的Android手机(例如Moto G4)，在低速3G网络上，以400ms RTT和400kbps的网络配置进行模拟测试。

我们有两个主要限制因素，对于在网络上快速展示页面有着巨大影响。一方面，由于[TCP慢启动](https://hpbn.co/building-blocks-of-tcp/#slow-start)，我们受到**网络传递限制**: HTML的前14KB（10个TCP数据包，每个1460字节，大约14.25 KB，[可以大概这样估计](https://www.tunetheweb.com/blog/critical-resources-and-the-first-14kb/)）是最关键的有效传输块，并且是内容中唯一可以在第一次网络往返就传输完成的部分（ 加上移动网络唤醒时间的原因，这就是您在RTT为400ms网络的环境下在1s内能获得的最多内容）。

（**注**：由于TCP通常无法充分利用网络连接，因此Google开发了[TCP瓶颈带宽和RRT（BBR）](https://cloud.google.com/blog/products/gcp/tcp-bbr-congestion-control-comes-to-gcp-your-internet-just-got-faster)，这是一种较新的为现代网络设计的[TCP延迟控制和TCP流控制的算法](https://medium.com/google-cloud/tcp-bbr-magic-dust-for-network-performance-57a5f1ccf437)。能够对实际 拥塞，而不是像TCP那样造成数据包丢失，[它明显更快](https://aws.amazon.com/blogs/networking-and-content-delivery/tcp-bbr-congestion-control-with-amazon-cloudfront/)，具有更高的吞吐量和更低的延迟-[算法的工作方式也不尽项同](https://blog.apnic.net/2017/05/09/bbr-new-kid-tcp-block/)。尽早确定优先资源的优先级仍然很重要，但14 KB可能与BBR无关 （谢谢V ictor, Barry！）

另一方面，由于JavaScript解析需要时间，我们在内存和CPU方面存在**硬件限制**（将在后面详细讨论）。为了实现上面所述的目标，我们必须考虑JavaScript的关键文件大小预算。关于该预算应该是多少（这在很大程度上取决于您的项目的性质）有不同的看法，但是压缩到170KB JavaScript的文件已经需要花费了1s才能在普通手机上进行解析和编译。假设170KB的文件在解压缩时扩展到原来的3倍（0.7MB），那在Moto G4 / G5 Plus上这类机型上就已经很大达到“体面的”用户体验了。

如果你想瞄准东南亚、非洲或印度等增长中的市场，你必须考虑一组非常不同的限制因素。Addy Osmani介绍了[主要的手机限制](https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6)，例如几乎没有低成本、高质量的设备、无法获得高质量的网络和较贵的流量，以及针对环境的PRPL-30性能预算和开发指南。

![12-30kb-front-end-performance-checklist-2020](./images/12-30kb-front-end-performance-checklist-2020.png)

>[根据Addy Osmani所述](https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6)，对于延迟加载的路由中的JS，建议的大小应 <35 KB

![13-prpl-budget-front-end-performance-checklist-2020](./images/13-prpl-budget-front-end-performance-checklist-2020.png)

>Addy Osmani建议，如果目标是智能手机，就采用PRPL-30性能预算(30KB gzipped+压缩后的初始化JS包)

事实上，谷歌的Alex Russel建议以130～170KB（gzipped后）作为一个合理的包大小上限。然而在现实世界中，大多数产品甚至都超过很多：现在JS包的中值大小约为417KB，与2015年初相比增长了42%。在中产收入的用户的移动设备上，这将带来15～25秒的可交互时间（TTI）。

![11-perf-phones-front-end-performance-checklist-2020](./images/11-perf-phones-front-end-performance-checklist-2020.jpeg)

>2019年全球销量最高智能手机的Geekbench CPU性能基准。JavaScript是强调单核性能(请记住，与Web平台的其余部分相比，它本质上更像是单线程的)，并且受CPU的限制。摘自Addy的文章[《在20美元的功能手机上快速加载网页》](https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6)

当然，JS包大小的最大值限制不是绝对的，我们可以超出上面说的JS包大小预算。我们可以根据浏览器主线程的活动(例如：开始渲染之前的绘制时间)设置性能预算，或者[跟踪前端对CPU的占用量](https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/)。[Calibre](https://calibreapp.com/)、[SpeedCurve](https://speedcurve.com/)和[Bundlesize](https://github.com/siddharthkp/bundlesize)等工具可以帮助您控制预算，并且可以集成到您的构建流程中。

最后，性能预算可能不应该是一个固定值。[根据网络连接的不同，性能预算应该有所调整](https://twitter.com/katiehempenius/status/1075478356311924737)。但是要记住，在慢网速下，无论如何使用，每个包大小都非常“昂贵”（占用宝贵的带宽）。

**注**：随着HTTP/2的广泛应用、即将到来的5G、快速发展的手机硬件和蓬勃发展的SPA的时代，设定如此僵化的预算听起来可能有些奇怪。然而，考虑我们面对的网络和硬件的不可预测性质时，这些性能预算限制听起来又确实是合理的，包括从拥堵的网络到缓慢发展的基础设施，到数据上限、代理浏览器、省流量模式和狡猾的漫游费用。

![file-size-budget-fast-default-addy-osmani-opt](./images/file-size-budget-fast-default-addy-osmani-opt.jpeg)

>来自Addy Osmani的[《默认快速:现代加载最佳实践》](https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices)(幻灯片19页)

![perf-budgets-network-connection](./images/perf-budgets-network-connection.jpeg)

>性能预算应根据一般的移动设备的网络条件进行调整(图片来源：Katie Hempenius)

## 定义环境

### 09 选择并设置构建工具

[不要过于关注那些被认为很酷的工具](https://24ways.org/2017/all-that-glisters/)。坚持在您的开发流程中进行构建优化，无论是Grunt、Gulp、Webpack、Parcel还是这些工具的组合。只要获得了想要的结果，并且维护构建过程没有问题，那就足够了。

在众多构建工具中，Rollup对开发者的吸引力越来越大，但Webpack似乎是最成熟的一个，它提供了数百个插件来优化构建的大小。尽管刚开始使用Webpack是很困难的。如但果你想开始，这里有一些很棒的资源：

+ [Webpack文档](https://webpack.js.org/concepts/) - 显然这是一个很好的起点，Raja Rao编写的[Webpack代码混淆](https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9)和Andrew Welch编写的[Webpack配置注释](An Annotated Webpack Config)都是了解webpack一个很好的起点。

+ Sean Larkin发布了1个关于Webpack的免费课程: [webpack核心概念](https://webpack.academy/p/the-core-concepts)。Jeffrey Way也发布了一个关于Webpack的非常棒的免费课程：[所有人都必须了解的webpack](https://laracasts.com/series/webpack-for-everyone)。这两个对每个想深入研究Webpack的开发者都很友好。

+ [webpack基础知识](https://frontendmasters.com/courses/webpack-fundamentals/)是1个非常全面的4小时课程，由Sean Larkin在FrontendMasters上发布。

+ 如果您的技术水平稍高一些，那么可以试试阅读Rowan Oulton发布的[使用Webpack改善建筑性能的现场指南](https://slack.engineering/keep-webpack-fast-a-field-guide-for-better-build-performance-f56a5995e8f1)，和BenediktRötsch进行的[有关将Webpack捆绑压缩的研究](https://www.contentful.com/blog/2017/10/27/put-your-webpack-bundle-on-a-diet-part-3/)。

+ [Webpack示例](https://github.com/webpack/webpack/tree/master/examples)有着数百个现成的Webpack配置，并按照主题和用途分类。另外:还有一个[Webpack配置生成器](https://webpack.jakoblind.no/)，可以生成一个基本的配置文件。

+ [awesome-webpack](https://github.com/webpack-contrib/awesome-webpack)是优秀的Webpack资源，库和工具的集合，有文章，视频，课程，书籍和示例等，包括在Angular，React中的最佳实践，当然也包括和框架无关的webpack资源。

### 10 默认使用渐进式增强

尽管这个概念已经提出了这么多年，将[渐进式增强](https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/)作为基础原则来指导前端体系结构和部署仍然是一个不错的选择。首先设计和构建基础和核心体验，然后使用强大的浏览器高级特性来增强体验，从而获得[弹性式](https://resilientwebdesign.com/)的用户体验。如果你的网站在低性能设备、网速慢、屏幕不好的环境下都能流畅地运行，那么运行速度快的机器上它就会运行得更快表现更佳。

实际上，通过[自适应服务模块](https://www.youtube.com/watch?v=puUPpVrIRkc&t=488s)，我们似乎正在逐步增强功能，为低端设备提供“精简”的核心体验，而为高端设备提供更复杂的功能。渐进式增强这种模式短期内应该不会消失。

### 11 选择一个良好的性能基准

由于有非常多的未知因素影响加载性能-网络、热节流、缓存覆盖、第三方脚本、解析器阻塞模式、磁盘I/O、IPC延迟、安装的扩展、防病毒软件和防火墙、后台CPU任务、硬件和内存限制、二级/三级缓存的差异、RTT -- 因此[JavaScript的体验成本非常高](https://v8.dev/blog/cost-of-javascript-2019)，仅次于默认情况下阻止页面呈现的Web字体和经常消耗太多内存的图像。随着[性能瓶颈从服务器转移到客户端](https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/)，作为开发人员，我们必须更详细地考虑所有这些未知因素。

上面提到的170KB的预算已经包含关键路径HTML/CSS/JavaScript、路由器、状态管理、实用程序、框架和应用程序逻辑，所以我们必须[彻底检查我们选择的框架的网络传输成本、解析/编译时间和运行时成本](https://www.twitter.com/kristoferbaxter/status/908144931125858304)。幸运的是在过去的几年里，[浏览器在解析和编译脚本的速度方面有了巨大的进步](https://v8.dev/blog/cost-of-javascript-2019)。然而，JavaScript的执行仍然是主要的性能瓶颈，因此我们必须密切关注脚本执行时间和网络传输可能会产生的任何影响。

正如Seb Markbège所[指出](https://twitter.com/sebmarkbage/status/829733454119989248)的，衡量框架启动成本的一个好方法是先渲染试图，然后删除试图再次渲染，这样就可以知框架scales的成本。因此首次渲染试图之前往往需要预热一堆延迟编译的代码，更大DOM树在scales时受益更多。二次渲染基本上是模拟页面上的代码复用度是如何随着页面复杂度的增加而影响性能特征。

### 12 评估框架和依赖关系

现在，[不是每个web应用都需要前端框架](https://twitter.com/jaffathecake/status/923805333268639744)，[在单页应用程序也不是每个页面都需要加载框架](not every page of a single-page-application needs to load a framework)。在Netflix的场景中，“从客户端删除React，一些第三方库和相应的应用程序代码可以将JavaScript的总量减少200KB以上，从而使Netflix首页退出登录的[可互动时间减少了50％以上](https://news.ycombinator.com/item?id=15567657)。” 然后，该团队利用用户在登录页面上花费的时间来预取React，这样做在用户可能访问的后续页面中就不用继续加载React了（[有关详细信息，请继续阅读](https://jakearchibald.com/2017/netflix-and-react/)）。

可能大家都知道，但还是值得一提：确实有一些项目可以[从完全删除现有框架受益](https://twitter.com/jaffathecake/status/925320026411950080)。选择框架后，您将至少使用几年，因此，如果需要使用框架，请确保您的选择是[明智的](https://www.youtube.com/watch?v=6I_GwgoGm1w)，并经过[深思熟虑](https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk)。

Inian Parameshwaran[评估了最流行的前50个框架的性能](https://youtu.be/wVY3-acLIoI?t=699)（用[First Contentful Paint](https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint)评估，即从导航到浏览器首次渲染DOM内容的时间）。Inian发现，Vue和Preact是总体来说最快的框架-在台式机和移动设备上都是如此，其次是React（[幻灯片](https://drive.google.com/file/d/1CoCQP7qyvkSQ4VG9L_PTWD5AF9wF28XT/view)）。 可以检查候选框架和建议的体系结构，并研究其中大多数解决方案的性能，例如使用服务器端渲染或客户端渲染，或者结合两者。

基准性能成本很重要。根据[Ankur Sethi的研究](https://blog.uncommon.is/the-baseline-costs-of-javascript-frameworks-f768e2865d4a)，“在印度，无论你如何优化，React应用程序在普通手机上的加载速度永远不会比1.1s快，Angular应用程序总是需要至少2.7s才能启动，Vue应用程序的用户至少需要等待1s才能开始使用它。” 当然，您可能并没有将印度作为您的主要市场，但是使用次优网络条件访问您的站点的用户将拥有类似的体验。当然，使用框架可能会降低用户体验，但您的团队也获得了可维护性和开发人员效率。因此使用框架需要经过深思熟虑。

您可以在Sacha Greif的[12分制评分系统](https://medium.freecodecamp.org/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library-3908c4ed3f49)上评估一个框架(或任何JavaScript库)包括：探索特性、可访问性、稳定性、性能、包生态系统、社区、学习曲线、文档、工具、跟踪记录、团队、兼容性、安全性等。考虑到整体耗时较大，在选择选项之前至少考虑总的大小成本+初始解析时间是个好主意；[Preact](https://github.com/developit/preact)、[Inferno](https://github.com/infernojs/inferno)、[Vue](https://vuejs.org/)、[Svelte](https://svelte.technology/)或[Polmer](https://github.com/Polymer/polymer)等轻量级框架可以很好地完成工作。基线的大小将定义应用程序代码的约束。

有许多工具可以帮助您就依赖项和可行替代方案的影响做出明智的决策：

+ [webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)
+ [Source Map Explorer](https://github.com/danvk/source-map-explorer)
+ [Bundle Buddy](https://github.com/samccone/bundle-buddy)
+ [Bundlephobia](https://bundlephobia.com/)
+ [Webpack size-plugin](https://github.com/GoogleChromeLabs/size-plugin)
+ [Import Cost for Visual Code](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost)

一个好的起点是为您的web应用程序选择一个好的默认种子。[Gatsby](http://gatsbyjs.org/)（React），[Vuepress](https://vuepress.vuejs.org/)（Vue），[Preact CLI](https://github.com/developit/preact-cli)和[PWA Starter Kit](https://github.com/Polymer/pwa-starter-kit)针对不同框架提供了合理的默认种子，可以在普通移动硬件上快速开箱即用。 另外，请查看[web.dev特定于针对React和Angular框架的性能指南](https://web.dev/learn/#frameworks)，该指南应该在今年晚些时候进行扩展（感谢Phillip！）。

![09-high-sell-phones-front-end-performance-checklist-2020](./images/09-high-sell-phones-front-end-performance-checklist-2020.png)

>畅销手机的CPU和计算性能（图片来源：Addy Osmani）

### 13 考虑使用PRPL模式和应用程序外壳架构

不同的框架对性能有不同的影响，需要不同的优化策略，因此您必须清楚地了解您将依赖的框架的所有细节。在构建Web应用程序时，建议研究[PRPL模式](https://developers.google.com/web/fundamentals/performance/prpl-pattern/)和[应用程序外壳架构](https://developers.google.com/web/updates/2015/11/app-shell)。这个理由非常简单：推送使初始化可交互所需的最少代码，以便快速呈现初始路由，然后使用Service Worker来缓存和预缓存资源，然后以异步方式延迟加载所需的路由。

![app-build-components-dibweb-c-scalew-879-opt](./images/app-build-components-dibweb-c-scalew-879-opt.png)

>PRPL代表推送关键资源（Pushing critical resource），渲染初始路由（Rendering initial route），预缓存剩余路由（Pre-caching remaining routes）和按需延迟加载剩余路由（Lazy-loading remaining routes on demand）

![appshell-1-o0t8qd-c-scalew-799-opt](./images/appshell-1-o0t8qd-c-scalew-799-opt.jpg)

>应用程序外壳是支持用户界面的最小HTML、CSS和JavaScript

### 14 是否对API的性能进行了优化？

API是指应用程序通过所谓的*端点*向内部和第三方应用程序交换数据的通信通道。在[设计和开发API时](https://www.smashingmagazine.com/2012/10/designing-javascript-apis-usability/)，我们需要一个合理的协议来实现服务器与第三方请求之间的通信。[代表性状态转移](https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/)（[REST](http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife)）是一种行之有效的逻辑选择：它定义了一组约束，开发人员可以遵循这些约束以使内容以高性能，可靠和可伸缩的方式进行访问。符合REST约束的Web服务称为*RESTful Web服务*。

与普通的HTTP请求一样，当从API检索数据时，服务器响应中的任何延迟都将传播到最终用户，从而影响渲染。当资源想要从API检索某些数据时，它将需要从相应的端点请求数据。渲染来自多个资源的数据的组件，例如在每个评论中包含评论和作者照片的文章，可能需要多次往返到服务器来获取所有数据，然后才能渲染。此外，通过REST返回的数据量通常超过渲染该组件所需的数据量。

如果许多资源都需要来自API的数据，则该API可能会成为性能瓶颈。[GraphQL](https://graphql.org/)为这些问题提供了高性能的解决方案。本身，GraphQL是API的查询语言，并且是服务器端运行时，用于通过使用为数据定义的类型系统执行查询。与REST不同，GraphQL可以在单个请求中检索所有数据，并且只响应所需的内容，而不会像REST通常那样过度或不足地获取数据。

此外，因为GraphQL使用模式（schema，定义数据结构的元数据)，所以它可以提前将数据组织成所需的结构，因此[使用GraphQL，我们可以删除用于处理状态管理的JavaScript代码](https://medium.com/@wmdmark/how-graphql-replaces-redux-3fff8289221d)，从而产生在客户机上运行更快的更干净的应用程序代码。

如果您想开始使用GraphQL，Eric Baer在Smashing Magazine上发表了两篇精彩的文章：[GraphQL入门：为什么我们需要一种新型API](https://www.smashingmagazine.com/2018/01/graphql-primer-new-api-part-1/)和[GraphQL入门：API设计的发展](https://www.smashingmagazine.com/2018/01/graphql-primer-new-api-part-2/)（感谢Leonardo提醒！）。

![redux-rest-apollo-graphql](./images/redux-rest-apollo-graphql.jpeg)

>REST和GraphQL之间的区别: 通过左侧的Redux+REST的对话和右侧的Apollo+GraphQL的对话来说明（图片来源：Hacker Noon）

### 15 使用AMP还是Instant Articles？

根据您团队的优先级和战略，您可能需要考虑使用Google的[AMP](https://www.ampproject.org/)或Facebook的[Instant Articles](https://instantarticles.fb.com/)或Apple的[Apple News](https://www.apple.com/news/)。 没有它们您也可以实现良好的性能，但是AMP确实提供了具有免费内容交付网络（CDN）的可靠性能框架，而Instant Articles可以提高您在Facebook上的可见性和性能。

这些技术为用户带来的明显好处是：基本可以保证性能，因此有时他们甚至更喜欢AMP/Apple News/Instant Pages的链接，而不是“常规”、可能比较臃肿的页面。对于处理大量第三方内容的内容繁重的网站，这些技术可能会明显地降低渲染耗时。

[这些并不是没用](https://timkadlec.com/remembers/2018-03-19-how-fast-is-amp-really/)。例如，根据Tim Kadlec的说法：“AMP文档往往比它们的同行更快，但这并不一定意味着这个页面性能更好。从性能的角度来看，AMP并没有太大的不用”。

对网站所有者来说，好处是显而易见的：这些格式在他们各自的平台上都容易被曝光，并且[在搜索引擎中提升了排名](https://ethanmarcotte.com/wrote/ampersand/)。您也可以通过重用AMP作为PWA的数据源，来构建[渐进式Web AMP](https://www.smashingmagazine.com/2016/12/progressive-web-amps/)。不利的一面？ 显然，有围墙的花园中开发的存在，使得开发人员需要开发和维护其内容的单独版本，例如在Apple的Instant Articles[没有实际的URL](https://www.w3.org/blog/TAG/2017/07/27/distributed-and-syndicated-content-whats-wrong-with-this-picture/)(感谢Addy，Jeremy！)。

### 16 明智地选择CDN

根据您拥有多少动态数据，您可以将内容的某些部分“外包”给[静态站点生成器](https://www.staticgen.com/)，将其推送到CDN并从中提供静态版本，从而避免数据库请求。您甚至可以选择基于CDN的[静态托管平台](https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/)，使用交互式组件作为增强功能丰富您的页面([JAMStack](https://jamstack.org/))。事实上，其中一些生成器(比如React生态的[Gatsby](https://www.gatsbyjs.org/blog/2017-09-13-why-is-gatsby-so-fast/))实际上就是[网站编译器](https://tomdale.net/2017/09/compilers-are-the-new-frameworks/)，它提供了许多开箱即用的自动化优化。随着编译器不断地为编译添加优化，编译后的输出会越来越小，越来越快。

请注意，CDN也可以提供（和卸载）动态内容。因此，不必将CDN的应用限制在静态资源。仔细检查您的CDN是否支持执行压缩和转换（例如，在格式方面进行图像优化，进行压缩和调整大小），[对servers worker的支持](https://www.filamentgroup.com/lab/servers-workers.html)，页面片段缓存，将它们在CDN层面组合页面的静态和动态部分（距离用户最近的服务器）和其他支持的特性。此外，请检查您的CDN[是否也支持HTTP over QUIC（HTTP/3）](https://blog.cloudflare.com/the-quicening/)。

注意：根据Patrick Meenan和Andy Davies的研究，[设置HTTP/2优先在许多CDN上实际上是无效的](https://github.com/andydavies/http2-prioritization-issues#cdns--cloud-hosting-services)，因此在选择CDN时要小心。帕特里克（Patrick）在他最近的[HTTP/2优先](https://youtu.be/sgjxuhFQktE?t=2626)演讲中有更多细节（感谢Barry！）。

## 资源优化

### 17 使用Brotli进行纯文本压缩

2015年，Google[推出了](https://opensource.googleblog.com/2015/09/introducing-brotli-new-compression.html)[Brotli](https://github.com/google/brotli)，这是一种全新的开源无损数据格式，[并被现在所有现代浏览器支持](http://caniuse.com/#search=brotli)。实际上，Brotli似乎比Gzip和Deflate[更有效](https://quixdb.github.io/squash-benchmark/#results-table)[得多](https://paulcalvano.com/index.php/2018/07/25/brotli-compression-how-much-will-it-reduce-your-content/)。取决于您的设置，压缩可能会（非常）缓慢，但是这样慢的压缩速度最终也会带来较高的压缩率。不管怎样，它都能快速解压缩。这篇文章可以[估算站点使用Brotli压缩可以节省的大小](https://tools.paulcalvano.com/compression.php)。

问题在于，使用Brotli压缩所有资源非常耗费计算资源和时间。因此，仅由于其产生的成本开销，许多服务器就无法使用它。实际上，在最高压缩级别下，Brotli是如此之慢，以至于服务器等待动态资源资产时，服务器开始发送响应所花费的时间会抵消文件大小减少带来的任何潜在收益。但是，对于静态资源压缩，应该[首选更高压缩比的压缩设置](https://css-tricks.com/brotli-static-compression/)。

如果您可以避开动态压缩静态资产的成本，Brotli就是值得的。Brotli可用于任何纯文本的内容-HTML，CSS，SVG，JavaScript等。

策略？ 使用最高压缩比配置的[Brotli+Gzip预压缩静态资源](https://css-tricks.com/brotli-static-compression/)，并使用Brotli配置3～5级压缩比来快速压缩（动态）HTML。确保服务器正确处理Brotli或gzip的内容协商头。

![04-compression-front-end-performance-checklist-2020](./images/04-compression-front-end-performance-checklist-2020.png)

>无论是在桌面还是移动设备上，有大约15%使用Brotli压缩。使用gzip压缩则大约是65%。其余部分完全没有压缩。(图像来源: [Web年鉴:压缩](https://almanac.httparchive.org/en/2019/compression))

### 18 使用响应式图像和WebP

尽可能使用具有`srcset`，`sizes`和`<picture>`元素的[响应式图像](https://www.smashingmagazine.com/2014/05/responsive-images-done-right-guide-picture-srcset/)。在使用它的同时，还可以通过`<picture>`元素和JPEG兜底（请参阅Andreas Bovens的[代码片段](https://dev.opera.com/articles/responsive-images/#different-image-types-use-case)）来使用[webP格式](https://www.smashingmagazine.com/2015/10/webp-images-and-performance/)（除Safari和iOS Safari外，所有现代浏览器均支持）。或使用内容协商（使用Accept标头）。Ire Aderinokun有一个非常详细的[教程](https://bitsofco.de/why-and-how-to-use-webp-images-today/)，将图像转换为WebP。

Sketch内置支持WebP，而Photoshop可以使用的[WebP插件](http://telegraphics.com.au/sw/product/WebPFormat#webpformat)从Photoshop导出WebP图像。[也有其他选项可用](https://developers.google.com/speed/webp/docs/using)，如果您使用的是WordPress或Joomla，也可以使用扩展来帮助您轻松实现对WebP的支持，例如WordPress的[Optimus](https://wordpress.org/plugins/optimus/)和[Cache Enabler](https://wordpress.org/plugins/cache-enabler/)以及[Joomla自己支持的扩展](https://extensions.joomla.org/extension/webp/)（通过Cody Arsenault）。

值得注意的是，虽然WebP图像文件大小与[同等的Guetzli和Zopfli相比](https://www.ctrl.blog/entry/webp-vs-guetzli-zopfli)，该格式不支持[像JPEG那样的渐进式渲染](https://youtu.be/jTXhYj2aCDU?t=630)，这就是为什么用户使用好的JPEG可能会更快地看到实际图像，尽管WebP图像的网络加载速度可能会更快。使用JPEG，我们可以用一半甚至四分之一的时间就提供给“像样的”用户体验，并在稍后加载其余的数据，而不是像WebP那样只有半空的图像。您的决定将取决于您想要的是什么：使用WebP，您将减少图像大小，而使用JPEG，您将提高图像的可感知性。

在Smashing Magazine上，我们使用后缀`-opt`作为图像名称-例如`brotli-compression-opt.png`； 每当图像包含该后缀时，团队中的每个人都知道该图像已经过优化。并且-不需要再加后缀了！-Jeremy Wagner甚至在[Smashing book上出版了一本《WebP》](https://www.smashingmagazine.com/ebooks/the-webp-manual/)。

![responsive-breakpoints-opt](./images/responsive-breakpoints-opt.jpeg)

>[响应式图像断点生成器](http://www.responsivebreakpoints.com/)可自动执行图像适配和标记生成

### 19 图像是否经过适当优化？

当您在落地页上时，快速加载特定图像非常关键，请确保JPEG是渐进式的，并使用[mozJPEG](https://github.com/mozilla/mozjpeg)压缩（通过操纵扫描级别来缩短图像初始化渲染的时间），或者看看[Guetzli](https://github.com/google/guetzli)，这是Google的新型开源编码器，专注于用户感知性能，并利用了Zopfli和WebP的经验。[唯一的缺点](https://medium.com/@fox/talk-the-state-of-the-web-3e12f8e413b3)是：处理时间慢（每百万像素一分钟的CPU）。 对于PNG，我们可以使用Pingo，对于SVG，我们可以使用[SVGO](https://www.npmjs.com/package/svgo)或[SVGOMG](https://jakearchibald.github.io/svgomg/)。 而且，如果您需要从网站上快速预览和复制或下载所有SVG资源，[svg-grabber](https://chrome.google.com/webstore/detail/svg-grabber-get-all-the-s/ndakggdliegnegeclmfgodmgemdokdmg)也可以为您做到这一点。

每一篇图像优化文章都会说的，但是又特别重要的一点：矢量资源整洁和紧密。确保清理未使用的资源，删除不必要的元数据，并减少图稿中路径点的数量（从而减少SVG代码）。（谢谢Jeremy！）

但是，还有更多高级的方案。你可以：

+ 使用[Squoosh](https://squoosh.app/)压缩、调整大小和处理图像，以获得最佳的压缩级别（有损或无损）
+ 使用[响应式图像断点生成器](http://www.responsivebreakpoints.com/)或[Cloudinary](Cloudinary)或[Imgix](https://www.imgix.com/)等服务来自动进行图像优化。同样，在大多数情况下，仅使用`srcset`和`size`将会获得显着的好处
+ 检查响应式标记的效率，可以使用[Imaging-heap](https://github.com/filamentgroup/imaging-heap)，这是一个命令行工具，可以测量视口大小和设备像素比率之间的效率
+ 对图片和Iframe进行懒加载，可以使用[混合懒加载](https://www.smashingmagazine.com/2019/05/hybrid-lazy-loading-progressive-migration-native/)、本地懒加载，或[懒加载](https://github.com/verlok/lazyload)库，它检测通过用户交互触发的可见性更改来实现懒加载（使用IntersectionObserver，我们将在后面进行探讨）
+ 对于屏幕外图像，我们可以先显示一个占位符，然后当图像出现在视口中时，使用IntersectionObserver触发网络调用，以将图像下载到后台。然后，我们可以[推迟渲染直到调用img.decode（）完成解码](https://youtu.be/YJGCZCaIZkQ?t=570)；如果[Image Decode API](https://medium.com/dailyjs/image-loading-with-image-decode-b03652e7d2d2)不可用，就直接下载图像。渲染图像时，我们可以使用淡入动画。 Katie Hempenius和Addy Osmani在他们的[性能提升：网络性能优化建议和技巧](https://youtu.be/YJGCZCaIZkQ?t=436)文章中分享了更多这方面的观点
+ 您可以[配置在“Pull Request”中自动图像压缩](https://github.com/marketplace/actions/image-actions)，因此任何图像都会在构建时完成压缩。这个Github Actions会对PNG和JPG使用mozjpeg和libvips进行压缩
+ 请注意默认情况下加载但可能永远都不会渲染的图像，例如网页中的“轮播图”，“手风琴”和“图像画廊”
+ [考虑使用“Sizes”属性更换请求的图像](https://www.filamentgroup.com/lab/sizes-swap/)，通过根据媒体查询来确定不同的图像显示尺寸。例如在“放大镜”组件中，通过设置`sizes`来触发替换图像资源
+ 每次上线前Review[页面中图像下载过程是否又不同](https://csswizardry.com/2018/06/image-inconsistencies-how-and-when-browsers-download-images/)，以防止意外下载不需要的前景和背景图像
+ 有时仅靠优化图像并不能解决问题。 为了缩短开始[渲染关键图像所需](https://calendar.perfplanet.com/2019/the-ugly-truth-about-optimising-beautiful-images/)的时间，请延迟加载不太重要的图像，并再关键图像渲染完成后再加载任何异步脚本
+ 如果要优化内部存储，可以使用Dropbox新的[Lepton格式](https://github.com/dropbox/lepton)，它的JPEG无损压缩率平均可以达到22％
+ 请注意CSS中的[aspect-ratio属性](https://drafts.csswg.org/css-sizing-4/#ratios)和[internalsize属性](https://github.com/ojanvafai/intrinsicsize-attribute)，这将允许我们设置图像的纵横比和尺寸，因此浏览器可以提前保留预定义的布局槽，这样在页面加载期间就可以[避免出现布局跳跃](https://24ways.org/2018/jank-free-image-loads/)
